const Class = require('../models/Class');
const School = require('../models/School');
const mongoose = require('mongoose');

// Cr√©er une nouvelle classe
exports.createClass = async (req, res) => {
  try {
    const { 
      name, level, section, room, capacity, schoolId, 
      academicYear, subjects, teacherId, teachers, resTeacher 
    } = req.body;
    
    console.log('üìù Donn√©es re√ßues pour cr√©ation:', { name, level, room, capacity, resTeacher, teacherId });
    
    // V√©rifier si l'√©cole existe
    const school = await School.findById(schoolId);
    if (!school) {
      return res.status(404).json({ message: '√âcole non trouv√©e' });
    }
    
    // V√©rifier si une classe avec le m√™me nom existe d√©j√† dans cette √©cole
    const existingClass = await Class.findOne({ name, schoolId });
    if (existingClass) {
      return res.status(400).json({ message: 'Une classe avec ce nom existe d√©j√† dans cette √©cole' });
    }

    // G√©n√©rer l'ann√©e scolaire si non fournie
    const currentYear = new Date().getFullYear();
    const defaultAcademicYear = `${currentYear}-${currentYear + 1}`;
    
    const newClass = new Class({
      name,
      level,
      section,
      room: room || 'Salle √† d√©finir',
      capacity: capacity || 40,
      schoolId,
      anneeScolaire: academicYear || defaultAcademicYear,
      subjects: subjects || [],
      
      // Gestion des professeurs (nouvelle structure)
      teachers: teachers || [],
      resTeacher: (resTeacher || teacherId) ? new mongoose.Types.ObjectId(resTeacher || teacherId) : null,
      
      // Initialisation des √©l√®ves et parents
      students: [],
      parents: [],
      emploiDuTemps: null,
      
      // Compatibilit√© avec l'ancienne structure
      academicYear: academicYear || defaultAcademicYear
    });
    
    const savedClass = await newClass.save();
    console.log('‚úÖ Classe cr√©√©e:', { id: savedClass._id, name: savedClass.name, resTeacher: savedClass.resTeacher });
    res.status(201).json(savedClass);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

// R√©cup√©rer toutes les classes
exports.getAllClasses = async (req, res) => {
  try {
    const classes = await Class.find()
      .populate('schoolId', 'name');
    res.json(classes);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

// R√©cup√©rer toutes les classes d'une √©cole sp√©cifique
exports.getClassesBySchool = async (req, res) => {
  console.log('\n=== üìö CONTROLLER: GET CLASSES BY SCHOOL ===');
  console.log('‚ö° Endpoint: GET /api/classes/school/:schoolId');
  
  try {
    const { schoolId } = req.params;
    console.log(`üîç Recherche de classes pour l'√©cole ID: ${schoolId}`);
    
    // NOUVEAU: Tra√ßage d√©taill√© de l'authentification
    if (!req.user) {
      console.warn('‚ö†Ô∏è ANOMALIE: Aucun utilisateur authentifi√© trouv√© dans la requ√™te');
      console.warn('‚ö†Ô∏è Le middleware auth.js devrait toujours d√©finir req.user, m√™me en mode contournement');
    } else {
      console.log(`üë§ Utilisateur: ID=${req.user.userId}, R√¥le=${req.user.role || 'non sp√©cifi√©'}`);
      
      // V√©rifier si c'est un utilisateur fant√¥me (mode contournement)
      if (req.user.isGhostUser) {
        console.log('‚ö†Ô∏è Mode contournement actif: Utilisateur fant√¥me d√©tect√©');
        console.log('‚ö†Ô∏è L\'acc√®s est accord√© sans v√©rification d\'autorisation r√©elle');
      }
    }
    
    // 1. Nettoyage et validation de l'ID d'√©cole
    const cleanSchoolId = schoolId.trim();
    console.log(`üßπ ID d'√©cole nettoy√©: ${cleanSchoolId}`);
    
    // V√©rification du format de l'ID avec gestion d'erreur d√©taill√©e
    let isValidObjectId = false;
    try {
      isValidObjectId = mongoose.Types.ObjectId.isValid(cleanSchoolId);
      console.log(`üî¢ Validation de l'ID MongoDB: ${isValidObjectId ? 'Valide ‚úì' : 'Invalide ‚úó'}`);
    } catch (validationErr) {
      console.error(`‚ùå Erreur lors de la validation de l'ID: ${validationErr.message}`);
    }
    
    if (!isValidObjectId) {
      console.error(`‚ùå ID d'√©cole invalide: ${cleanSchoolId}`);
      return res.status(400).json({ 
        message: 'ID d\'√©cole invalide', 
        details: 'Format MongoDB ObjectId invalide',
        schoolId: cleanSchoolId
      });
    }
    
    // 2. Recherche de l'√©cole avec gestion robuste d'erreurs
    console.log(`üîç Recherche de l'√©cole avec ID: ${cleanSchoolId}...`);
    
    let school = null;
    try {
      school = await School.findById(cleanSchoolId);
    } catch (schoolFindErr) {
      console.error(`‚ùå Erreur lors de la recherche de l'√©cole: ${schoolFindErr.message}`);
      return res.status(500).json({ 
        message: 'Erreur lors de la recherche de l\'√©cole',
        details: schoolFindErr.message
      });
    }
    
    // G√©rer le cas o√π l'√©cole n'est pas trouv√©e
    if (!school) {
      console.error(`‚ùå √âcole non trouv√©e avec l'ID: ${cleanSchoolId}`);
      
      // CONTOURNEMENT: Si l'√©cole n'est pas trouv√©e, cr√©er une √©cole fictive pour les tests
      if (process.env.NODE_ENV !== 'production') {
        console.log('‚ö†Ô∏è CONTOURNEMENT: Cr√©ation d\'une √©cole fictive pour les tests');
        
        const dummySchool = {
          _id: cleanSchoolId,
          name: "√âcole fictive pour d√©bogage",
          address: "123 Rue Debug",
          status: "Test"
        };
        
        // Utiliser cette √©cole fictive pour continuer le traitement
        school = dummySchool;
        console.log(`‚úÖ √âcole fictive cr√©√©e: ${school.name}`);
      } else {
        // En production, renvoyer une erreur 404 normale
        return res.status(404).json({ 
          message: '√âcole non trouv√©e', 
          details: `Aucune √©cole trouv√©e avec l'ID ${cleanSchoolId}`,
          schoolId: cleanSchoolId
        });
      }
    } else {
      console.log(`‚úÖ √âcole trouv√©e: ${school.name} (ID: ${school._id})`);
    }
    
    // 3. R√©cup√©ration des classes avec protection contre les erreurs
    try {
      console.log(`üîç Recherche des classes pour l'√©cole ${school.name}...`);
      
      // IMPORTANT: Utiliser une requ√™te optimis√©e avec la nouvelle structure
      const classQuery = Class.find({ schoolId: cleanSchoolId })
        .populate('schoolId', 'name')
        .populate('teachers', 'firstName lastName name email') // Tous les professeurs
        .populate('resTeacher', 'firstName lastName name email') // Professeur principal - inclut name et firstName/lastName
        .populate('students', 'firstName lastName name email') // √âl√®ves assign√©s
        .populate('parents', 'firstName lastName name email') // Parents des √©l√®ves
        .select('name level section room capacity studentCount teachers resTeacher students parents subjects anneeScolaire createdAt updatedAt') // Nouvelle structure
        .limit(500); // S√©curit√©: limiter le nombre de r√©sultats
      
      // Ex√©cuter la requ√™te
      const classes = await classQuery;
      
      console.log(`‚úÖ ${classes.length} classes trouv√©es pour l'√©cole ${school.name}`);
      
      // Tra√ßage pour le d√©bogage
      if (classes.length > 0) {
        console.log('üìã Exemples de classes trouv√©es:');
        classes.slice(0, 3).forEach(c => {
          console.log(`   - ${c._id}: ${c.name} (${c.level || 'Niveau non sp√©cifi√©'})`);
        });
      }
      
      // Renvoyer les donn√©es en format JSON
      return res.json(classes);
    } catch (classError) {
      console.error(`‚ùå Erreur lors de la recherche des classes: ${classError.message}`);
      console.log('Renvoi d\'un tableau vide comme solution de contournement');
      
      // M√™me en cas d'erreur, renvoyer un tableau vide pour √©viter de bloquer le client
      return res.json([]);
    }
  } catch (err) {
    console.error(`Erreur lors de la r√©cup√©ration des classes: ${err.message}`);
    res.status(500).json({ message: 'Erreur serveur lors de la r√©cup√©ration des classes', details: err.message });
  }
};

// R√©cup√©rer une classe par ID
exports.getClassById = async (req, res) => {
  try {
    const classItem = await Class.findById(req.params.id)
      .populate('schoolId', 'name')
      .populate('teacherIds', 'name email');
    
    if (!classItem) {
      return res.status(404).json({ message: 'Classe non trouv√©e' });
    }
    
    res.json(classItem);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

// Mettre √† jour une classe
exports.updateClass = async (req, res) => {
  try {
    const { 
      name, level, section, room, capacity, academicYear, anneeScolaire, subjects,
      teachers, resTeacher, students, parents, emploiDuTemps
    } = req.body;
    
    console.log('üìù Donn√©es re√ßues pour mise √† jour:', { name, level, room, capacity, resTeacher, id: req.params.id });
    
    // V√©rifier si une classe avec le m√™me nom existe d√©j√† (si le nom est mis √† jour)
    if (name) {
      const existingClass = await Class.findOne({ 
        name, 
        schoolId: req.body.schoolId || req.params.schoolId,
        _id: { $ne: req.params.id }
      });
      
      if (existingClass) {
        return res.status(400).json({ message: 'Une classe avec ce nom existe d√©j√† dans cette √©cole' });
      }
    }

    const updateData = {};
    if (name !== undefined) updateData.name = name;
    if (level !== undefined) updateData.level = level;
    if (section !== undefined) updateData.section = section;
    if (room !== undefined) updateData.room = room;
    if (capacity !== undefined) updateData.capacity = capacity;
    if (academicYear !== undefined) updateData.academicYear = academicYear;
    if (anneeScolaire !== undefined) updateData.anneeScolaire = anneeScolaire;
    if (subjects !== undefined) updateData.subjects = subjects;
    
    // Nouveaux champs de la structure
    if (teachers !== undefined) updateData.teachers = teachers;
    if (resTeacher !== undefined) {
      updateData.resTeacher = resTeacher ? new mongoose.Types.ObjectId(resTeacher) : null;
    }
    if (students !== undefined) {
      updateData.students = students;
      updateData.studentCount = students.length; // Calculer automatiquement
    }
    if (parents !== undefined) updateData.parents = parents;
    if (emploiDuTemps !== undefined) updateData.emploiDuTemps = emploiDuTemps;
    
    const updatedClass = await Class.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true }
    );
    
    if (!updatedClass) {
      return res.status(404).json({ message: 'Classe non trouv√©e' });
    }
    
    console.log('‚úÖ Classe mise √† jour:', { id: updatedClass._id, name: updatedClass.name, resTeacher: updatedClass.resTeacher });
    res.json(updatedClass);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

// Supprimer une classe
exports.deleteClass = async (req, res) => {
  try {
    const classId = req.params.id;
    const deletedClass = await Class.findByIdAndDelete(classId);
    
    if (!deletedClass) {
      return res.status(404).json({ message: 'Classe non trouv√©e' });
    }
    
    // Mettre √† jour les utilisateurs (√©tudiants) assign√©s √† cette classe
    // pour les rendre "non assign√©s"
    const User = require('../models/User');
    await User.updateMany(
      { classId: classId }, 
      { $unset: { classId: 1 } }
    );
    
    console.log(`Classe ${deletedClass.nom} supprim√©e. √âtudiants remis en "non assign√©s".`);
    res.json({ message: 'Classe supprim√©e avec succ√®s et √©tudiants remis en "non assign√©s"' });
  } catch (err) {
    console.error('Erreur lors de la suppression de la classe:', err);
    res.status(500).json({ message: err.message });
  }
};

// R√©cup√©rer les statistiques d'une classe
exports.getClassStats = async (req, res) => {
  try {
    const { classId } = req.params;
    
    // V√©rifier si la classe existe
    const classInfo = await Class.findById(classId);
    if (!classInfo) {
      return res.status(404).json({ message: 'Classe non trouv√©e' });
    }
    
    // Importer le mod√®le User pour compter les √©tudiants
    const User = require('../models/User');
    
    // Compter le nombre d'√©tudiants assign√©s √† cette classe
    const studentsCount = await User.countDocuments({ 
      classId: classId,
      role: 'student' 
    });
    
    // Calculer les statistiques
    const stats = {
      classInfo: {
        _id: classInfo._id,
        name: classInfo.name,
        level: classInfo.level,
        section: classInfo.section,
        capacity: classInfo.capacity || 0,
        academicYear: classInfo.academicYear,
        subjects: classInfo.subjects || []
      },
      studentsCount: studentsCount,
      availableSpots: Math.max(0, (classInfo.capacity || 0) - studentsCount),
      occupancyRate: classInfo.capacity ? Math.round((studentsCount / classInfo.capacity) * 100) : 0,
      isFull: classInfo.capacity ? studentsCount >= classInfo.capacity : false
    };
    
    res.json(stats);
  } catch (err) {
    console.error('Erreur lors de la r√©cup√©ration des statistiques de classe:', err);
    res.status(500).json({ message: err.message });
  }
};

// R√©cup√©rer la liste de toutes les mati√®res existantes
exports.getAllSubjects = async (req, res) => {
  try {
    const classes = await Class.find();
    
    // Extraire toutes les mati√®res de toutes les classes
    const allSubjects = classes.reduce((acc, cls) => {
      if (cls.subjects && cls.subjects.length) {
        return [...acc, ...cls.subjects];
      }
      return acc;
    }, []);
    
    // Supprimer les doublons
    const uniqueSubjects = [...new Set(allSubjects)].sort();
    
    res.json(uniqueSubjects);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};
